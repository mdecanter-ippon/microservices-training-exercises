meta {
  name: Confirm Order - Complete Trace
  type: http
  seq: 3
}

post {
  url: {{order_service_url}}/orders/{{order_id}}/confirm
  body: json
  auth: bearer
}

auth:bearer {
  token: {{alice_token}}
}

body:json {
  {
    "recipientName": "Alice Martin"
  }
}

tests {
  test("Status is 200 OK", function() {
    expect(res.getStatus()).to.equal(200);
  });

  test("Order status is SHIPPED", function() {
    const body = res.getBody();
    expect(body.status).to.equal('SHIPPED');
  });

  test("Order has tracking number", function() {
    const body = res.getBody();
    expect(body.trackingNumber).to.be.a('string');
    expect(body.trackingNumber).to.match(/^SHIP-/);
  });

  test("Order has shipment ID", function() {
    const body = res.getBody();
    expect(body.shipmentId).to.be.a('string');
  });
}

docs {
  # Confirm Order - Complete Distributed Trace

  This request completes the distributed trace by confirming and shipping the order.

  **Prerequisite:** Run "Create Order - Distributed Trace" first to get an order ID.

  **Request Flow (this step):**
  ```
  Client
    |
    | POST /orders/{id}/confirm (with Alice's token)
    v
  order-service
    |
    └─→ POST /shipments (with M2M token)
        └── shipment-service -> Creates shipment with tracking
  ```

  **Complete Trace in Zipkin:**
  After running both requests (Create + Confirm), open Zipkin at http://localhost:9411

  You should see TWO traces:
  1. **Create Order trace:** order-service → user-service (user validation)
  2. **Confirm Order trace:** order-service → shipment-service (shipment creation)

  **Why two-step flow?**
  - Demonstrates realistic order lifecycle: PENDING → SHIPPED
  - Shows separate traces for different business operations
  - User validation and shipment creation are decoupled

  **M2M Authentication:**
  The order-service uses client_credentials flow to call shipment-service:
  - No user context needed for service-to-service calls
  - Service-to-service trust via OAuth2 client credentials
  - Trace context still propagated across services
}
